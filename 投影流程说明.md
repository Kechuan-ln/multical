# Mocap到GoPro投影流程说明

## 数据概览

### 输入数据

| 数据 | 路径 | 说明 |
|------|------|------|
| **Mocap CSV** | `/Volumes/FastACIS/GoPro/motion/mocap/mocap.csv` | OptiTrack导出的marker 3D坐标（毫米，120fps） |
| **GoPro视频** | `/Volumes/FastACIS/GoPro/motion/Cam4/Video.MP4` | GoPro Cam4录制的视频（60fps，3840x2160） |
| **OptiTrack标定** | `/Volumes/FastACIS/GoPro/motion/mocap/Primecolor.mcal` | OptiTrack系统的Mocap→PrimeColor外参 |
| **Multical标定** | `/Volumes/FastACIS/GoPro/motion/calibration.json` | ChArUco板标定的PrimeColor→GoPro外参和GoPro内参 |
| **Marker标签** | `marker_labels.csv` | Marker ID到身体部位的映射（可选） |

### 坐标系说明

```
OptiTrack坐标系：
  X: 右
  Y: 上
  Z: 后（-Z前向）

标准OpenCV坐标系：
  X: 右
  Y: 下
  Z: 前（+Z前向）
```

## 投影流程

### 完整管线

```
1. Mocap世界坐标 (OptiTrack, -Z前向, mm)
   ↓ 转换为米

2. Mocap世界坐标 (OptiTrack, -Z前向, m)
   ↓ R_w2p @ p + T_w2p  (来自.mcal或custom JSON)

3. PrimeColor相机坐标 (OptiTrack约定, -Z前向)
   ↓ YZ翻转: diag[1, -1, -1]

4. PrimeColor相机坐标 (标准约定, +Z前向)
   ↓ R_p2g.T @ (p - T_p2g)  (逆变换，来自calibration.json)

5. GoPro相机坐标 (标准约定, +Z前向)
   ↓ cv2.projectPoints(K_gopro, dist_gopro)

6. GoPro图像2D坐标 (像素)
```

### 关键转换

**坐标系翻转**:
```python
R_OPTI_TO_STD = diag([1, -1, -1])  # YZ翻转
```

**逆变换**（PrimeColor→GoPro）:
```python
R_inv = R_p2g.T
T_inv = -R_inv @ T_p2g
points_gopro = R_inv @ points_prime + T_inv
```

## 时间同步

### 同步参数

```python
sync_offset = 10.5799秒  # GoPro相对于Mocap的时间偏移
mocap_fps = 120.0         # Mocap采样率
gopro_fps = 59.94         # GoPro视频帧率
```

### 帧映射

```python
gopro_time = gopro_frame / gopro_fps
mocap_time = gopro_time - sync_offset
mocap_frame = round(mocap_time * mocap_fps)
```

**重要**: 由于sync_offset=10.5799秒，前635帧（约10.6秒）的GoPro视频无法映射到Mocap数据。

## 测试工具

### 1. 坐标转换测试

```bash
python debug_marker_projection.py
```

**输出示例**:
```
世界坐标 (OptiTrack, mm): [496.06, 516.09, 2854.69]
PrimeColor坐标 (OptiTrack): [-0.061, -1.427, -1.834]  # Z<0正常
PrimeColor坐标 (标准): [-0.061, 1.427, 1.834]        # Z>0正确
GoPro坐标: [0.541, 0.414, 1.016]                     # Z>0可见
```

### 2. 帧映射测试

```bash
python debug_frame_mapping.py
```

**关键发现**:
- 第一个有效GoPro帧: 635
- 前635帧mocap_time < 0，无法映射

### 3. Marker投影测试

```bash
bash run_marker_projection_test.sh
```

**测试范围**: GoPro帧635-935（300帧，约5秒）

**输出**:
- `marker_projection_mcal.mp4` - 使用OptiTrack标定
- `marker_projection_custom.mp4` - 使用自定义标定

**验证方法**:
- ✓ Marker点是否在人体上
- ✓ 标签是否对应正确部位
- ✓ 深度关系是否合理

## 两种外参对比

### OptiTrack .mcal

- **来源**: OptiTrack系统内部标定
- **优点**: 与Mocap数据天然对齐
- **使用**: 默认方式（无需额外参数）

### 自定义JSON

- **来源**: ChArUco板标定
- **优点**: 可独立验证和调整
- **使用**: 添加 `--extrinsics-json extrinsics_calibrated.json`

### 差异

通过 `test_custom_vs_mcal_extrinsics.py` 测试发现：
- R矩阵差异: 最大0.065（约3.7°）
- T向量差异: 最大371mm
- 投影差异: Pelvis位置相差281mm

**结论**: 两种标定来自不同来源，需通过实际投影效果选择。

## 常见问题

### Q1: 投影帧数为0？

**原因**: 起始帧号太小，mocap_time < 0

**解决**: 从第635帧开始，或调整sync_offset

### Q2: Marker在相机后面？

**检查**:
```python
# 最终GoPro坐标的Z值
if z_gopro < 0:
    print("Marker在相机后面，不可见")
```

### Q3: 坐标系转换错误？

**验证**:
```python
# OptiTrack坐标系：Z应该<0
assert marker_prime_opti[2] < 0

# 翻转后：Z应该>0
assert marker_prime_std[2] > 0
```

### Q4: 哪种外参更准？

**方法**:
1. 运行 `bash run_marker_projection_test.sh`
2. 对比两个输出视频
3. 选择marker投影更准确的

## 文件清单

### 核心脚本

- `project_markers_to_gopro.py` - Marker投影主脚本
- `project_skeleton_to_gopro_FINAL_FIXED.py` - Skeleton投影脚本

### 测试工具

- `debug_marker_projection.py` - 坐标转换测试
- `debug_frame_mapping.py` - 帧映射测试
- `test_custom_vs_mcal_extrinsics.py` - 外参对比

### 运行脚本

- `run_marker_projection_test.sh` - 快速测试
- `run_projection_with_custom_extrinsics.sh` - 对比两种外参

### 文档

- `MARKER_PROJECTION_TEST_README.md` - Marker投影详细文档
- `EXTRINSICS_COMPARISON_GUIDE.md` - 外参对比指南

## 快速开始

```bash
# 1. 测试坐标转换
python debug_marker_projection.py

# 2. 测试帧映射
python debug_frame_mapping.py

# 3. 测试Marker投影
bash run_marker_projection_test.sh

# 4. 查看结果
# 打开 marker_projection_mcal.mp4 和 marker_projection_custom.mp4
```

---

**最后更新**: 2025年
**版本**: 1.0
